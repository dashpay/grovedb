# التشفير الكمي — تحليل التهديدات ما بعد الكم

يحلل هذا الفصل كيف ستؤثر الحواسيب الكمية على المكونات التشفيرية الأساسية المستخدمة في GroveDB وبروتوكولات المعاملات المحمية المبنية فوقه (Orchard، Dash Platform). يغطي الفصل المكونات المعرضة للخطر، والمكونات الآمنة، وما يعنيه "اجمع الآن، فك التشفير لاحقاً" للبيانات المخزنة، واستراتيجيات التخفيف الموجودة — بما في ذلك تصاميم KEM الهجينة.

## خوارزميتان كميتان مهمتان

هناك خوارزميتان كميتان فقط ذات صلة بالتشفير عملياً:

**خوارزمية Shor** تحل مسألة اللوغاريتم المتقطع (وتحليل الأعداد الصحيحة إلى عوامل) في زمن متعدد الحدود. بالنسبة لمنحنى إهليلجي بطول 255 بت مثل Pallas، يتطلب ذلك حوالي 510 كيوبت منطقي — لكن مع حمل تصحيح الأخطاء، يكون المتطلب الفعلي حوالي 4 ملايين كيوبت فيزيائي. خوارزمية Shor **تكسر بالكامل** جميع تشفيرات المنحنى الإهليلجي بغض النظر عن حجم المفتاح.

**خوارزمية Grover** توفر تسريعاً تربيعياً للبحث بالقوة الغاشمة. مفتاح متماثل بطول 256 بت يصبح فعلياً 128 بت. ومع ذلك، عمق الدائرة لـ Grover على فضاء مفاتيح 128 بت لا يزال 2^64 عملية كمية — يعتقد كثير من خبراء التشفير أن هذا لن يكون عملياً أبداً على العتاد الحقيقي بسبب حدود فقدان الترابط. Grover يقلل هوامش الأمان لكنه لا يكسر التشفير المتماثل ذو المعاملات الجيدة.

| الخوارزمية | الأهداف | التسريع | التأثير العملي |
|-----------|---------|---------|------------------|
| **Shor** | ECC اللوغاريتم المتقطع، تحليل RSA | أسي (زمن متعدد الحدود) | **كسر كامل** لـ ECC |
| **Grover** | البحث عن مفاتيح متماثلة، صورة أولية للتجزئة | تربيعي (يُنصّف بتات المفتاح) | 256 بت → 128 بت (لا يزال آمناً) |

## المكونات التشفيرية الأساسية في GroveDB

يستخدم GroveDB وبروتوكول الحماية المبني على Orchard مزيجاً من مكونات المنحنى الإهليلجي والمكونات المتماثلة/القائمة على التجزئة. يصنف الجدول أدناه كل مكون حسب ثغرته الكمية:

### معرضة للكم (خوارزمية Shor — 0 بت ما بعد الكم)

| المكون الأساسي | مكان الاستخدام | ما الذي ينكسر |
|-----------|-----------|-------------|
| **Pallas ECDLP** | التزامات الملاحظات (cmx)، المفاتيح المؤقتة (epk/esk)، مفاتيح العرض (ivk)، مفاتيح الدفع (pk_d)، اشتقاق المُبطِلات | استرداد أي مفتاح خاص من نظيره العام |
| **اتفاق مفاتيح ECDH** (Pallas) | اشتقاق مفاتيح التشفير المتماثل لنصوص الملاحظات المشفرة | استرداد السر المشترك → فك تشفير جميع الملاحظات |
| **تجزئة Sinsemilla** | مسارات Merkle لـ CommitmentTree، التجزئة داخل الدائرة | مقاومة التصادم تعتمد على ECDLP؛ تتدهور عند كسر Pallas |
| **Halo 2 IPA** | نظام إثبات ZK (التزام متعدد الحدود على منحنيات Pasta) | تزوير إثباتات لعبارات كاذبة (تزييف، إنفاق غير مصرح) |
| **التزامات Pedersen** | التزامات القيمة (cv_net) التي تخفي مبالغ المعاملات | استرداد المبالغ المخفية؛ تزوير إثباتات التوازن |

### آمنة كمياً (خوارزمية Grover — 128+ بت ما بعد الكم)

| المكون الأساسي | مكان الاستخدام | الأمان ما بعد الكم |
|-----------|-----------|----------------------|
| **Blake3** | تجزئات عقد شجرة Merk، عقد MMR، جذور حالة BulkAppendTree، بادئات مسارات الأشجار الفرعية | 128 بت صورة أولية، 128 بت صورة أولية ثانية |
| **BLAKE2b-256** | KDF لاشتقاق المفاتيح المتماثلة، مفتاح التشفير الصادر، PRF^expand | 128 بت صورة أولية |
| **ChaCha20-Poly1305** | تشفير enc_ciphertext و out_ciphertext (مفاتيح 256 بت) | 128 بت بحث عن المفتاح (آمن، لكن مسار اشتقاق المفتاح عبر ECDH ليس كذلك) |
| **PRF^expand** (BLAKE2b-512) | اشتقاق esk، rcm، psi من rseed | 128 بت أمان PRF |

### بنية GroveDB التحتية: آمنة كمياً بالكامل

تعتمد جميع هياكل بيانات GroveDB الخاصة حصرياً على تجزئة Blake3:

- **أشجار Merk AVL** — تجزئات العقد، combined_value_hash، نشر تجزئة الأبناء
- **أشجار MMR** — تجزئات العقد الداخلية، حساب القمم، اشتقاق الجذر
- **BulkAppendTree** — سلاسل تجزئة المخزن المؤقت، جذور Merkle الكثيفة، MMR الحقبة
- **جذر حالة CommitmentTree** — `blake3("ct_state" || sinsemilla_root || bulk_state_root)`
- **بادئات مسارات الأشجار الفرعية** — تجزئة Blake3 لأجزاء المسار
- **إثباتات V1** — سلاسل المصادقة عبر تسلسل Merk

**لا حاجة لتغييرات.** تظل إثباتات شجرة Merk في GroveDB، وفحوصات اتساق MMR، وجذور حقب BulkAppendTree، وجميع سلاسل مصادقة إثباتات V1 آمنة ضد الحواسيب الكمية. البنية التحتية القائمة على التجزئة هي الجزء الأقوى في النظام ما بعد الكم.

## التهديدات بأثر رجعي مقابل التهديدات الآنية

هذا التمييز حاسم لتحديد أولويات ما يجب إصلاحه ومتى.

**التهديدات بأثر رجعي** تخترق البيانات المخزنة بالفعل. يسجل الخصم البيانات اليوم ويفك تشفيرها عندما تصبح الحواسيب الكمية متاحة. هذه التهديدات **لا يمكن التخفيف منها بعد وقوعها** — بمجرد أن تكون البيانات على السلسلة، لا يمكن إعادة تشفيرها أو استردادها.

**التهديدات الآنية** تؤثر فقط على المعاملات المنشأة في المستقبل. يمكن لخصم يمتلك حاسوباً كمياً تزوير التوقيعات أو الإثباتات، لكن فقط للمعاملات الجديدة. المعاملات القديمة تم التحقق منها وتأكيدها بالفعل من قبل الشبكة.

| التهديد | النوع | ما يُكشف | الإلحاح |
|--------|------|---------------|---------|
| **فك تشفير الملاحظات** (enc_ciphertext) | **بأثر رجعي** | محتويات الملاحظة: المستلم، المبلغ، المذكرة، rseed | **عالي** — مخزن إلى الأبد |
| **فتح التزام القيمة** (cv_net) | **بأثر رجعي** | مبالغ المعاملات (لكن ليس المرسل/المستلم) | **متوسط** — المبالغ فقط |
| **بيانات استرداد المرسل** (out_ciphertext) | **بأثر رجعي** | مفاتيح استرداد المرسل للملاحظات المرسلة | **عالي** — مخزن إلى الأبد |
| تزوير تفويض الإنفاق | آني | يمكن تزوير توقيعات إنفاق جديدة | منخفض — الترقية قبل وصول QC |
| تزوير إثبات Halo 2 | آني | يمكن تزوير إثباتات جديدة (تزييف) | منخفض — الترقية قبل وصول QC |
| تصادم Sinsemilla | آني | يمكن تزوير مسارات Merkle جديدة | منخفض — مشمول في تزوير الإثباتات |
| تزوير توقيع الربط | آني | يمكن تزوير إثباتات توازن جديدة | منخفض — الترقية قبل وصول QC |

### ما الذي يُكشف بالتحديد؟

**إذا كُسر تشفير الملاحظات** (تهديد HNDL الرئيسي):

يسترد الخصم الكمي `esk` من `epk` المخزن عبر خوارزمية Shor، ويحسب السر المشترك لـ ECDH، ويشتق المفتاح المتماثل، ويفك تشفير `enc_ciphertext`. يكشف هذا عن النص الكامل للملاحظة:

| الحقل | الحجم | ما يكشفه |
|-------|------|----------------|
| version | 1 byte | إصدار البروتوكول (غير حساس) |
| diversifier | 11 bytes | مكون عنوان المستلم |
| value | 8 bytes | مبلغ المعاملة الدقيق |
| rseed | 32 bytes | يتيح ربط المُبطِلات (إزالة إخفاء هوية مخطط المعاملات) |
| memo | 36 bytes (DashMemo) | بيانات التطبيق، قد تكون مُعرِّفة |

مع `rseed` و `rho` (المخزنين مع النص المشفر)، يمكن للخصم حساب `esk = PRF(rseed, rho)` والتحقق من ربط المفتاح المؤقت. مع الدمج مع diversifier، يربط هذا المدخلات بالمخرجات عبر تاريخ المعاملات بالكامل — **إزالة كاملة لإخفاء هوية مجمع الحماية**.

**إذا كُسرت التزامات القيمة فقط** (تهديد HNDL الثانوي):

يسترد الخصم `v` من `cv_net = [v]*V + [rcv]*R` بحل ECDLP. يكشف هذا عن **مبالغ المعاملات لكن ليس هوية المرسل أو المستلم**. يرى الخصم "أحدهم أرسل 5.0 Dash لأحدهم" لكنه لا يستطيع ربط المبلغ بأي عنوان أو هوية دون كسر تشفير الملاحظات أيضاً.

المبالغ وحدها بدون ربط محدودة الفائدة. لكن مع دمج البيانات الخارجية (التوقيت، الفواتير المعروفة، المبالغ المطابقة للطلبات العامة)، تصبح هجمات الارتباط ممكنة.

## هجوم "اجمع الآن، فك التشفير لاحقاً"

هذا هو التهديد الكمي الأكثر إلحاحاً وعملية.

**نموذج الهجوم:** خصم على مستوى الدولة (أو أي طرف لديه سعة تخزين كافية) يسجل جميع بيانات المعاملات المحمية على السلسلة اليوم. هذه البيانات متاحة علنياً على البلوكتشين وغير قابلة للتغيير. ينتظر الخصم حاسوباً كمياً ذا صلة تشفيرية (CRQC)، ثم:

```text
Step 1: Read stored record from CommitmentTree BulkAppendTree:
        cmx (32) || rho (32) || epk (32) || enc_ciphertext (104) || out_ciphertext (80)

Step 2: Solve ECDLP on Pallas via Shor's algorithm:
        epk = [esk] * g_d  →  recover esk

Step 3: Compute shared secret:
        shared_secret = [esk] * pk_d

Step 4: Derive symmetric key (BLAKE2b is quantum-safe, but input is compromised):
        K_enc = BLAKE2b-256("Zcash_OrchardKDF", shared_secret || epk)

Step 5: Decrypt enc_ciphertext using ChaCha20-Poly1305:
        → version || diversifier || value || rseed || memo

Step 6: With rseed + rho, link nullifiers to note commitments:
        esk = PRF(rseed, rho)
        → full transaction graph reconstruction
```

**الرؤية الأساسية:** التشفير المتماثل (ChaCha20-Poly1305) آمن كمياً تماماً. الثغرة بالكامل في **مسار اشتقاق المفتاح** — المفتاح المتماثل يُشتق من السر المشترك لـ ECDH، و ECDH يُكسر بخوارزمية Shor. المهاجم لا يكسر التشفير؛ بل يسترد المفتاح.

**الأثر الرجعي:** هذا الهجوم **رجعي بالكامل**. يمكن فك تشفير كل ملاحظة مشفرة مخزنة على السلسلة بمجرد وجود CRQC. لا يمكن إعادة تشفير البيانات أو حمايتها بعد ذلك. لهذا يجب معالجته قبل تخزين البيانات، وليس بعدها.

## التخفيف: KEM الهجين (ML-KEM + ECDH)

الدفاع ضد HNDL هو اشتقاق مفتاح التشفير المتماثل من **آليتي اتفاق مفاتيح مستقلتين**، بحيث لا يكفي كسر واحدة فقط. هذا يُسمى KEM الهجين.

### ML-KEM-768 (CRYSTALS-Kyber)

ML-KEM هي آلية تغليف مفاتيح ما بعد الكم المعيارية من NIST (FIPS 203، أغسطس 2024) المبنية على مسألة التعلم مع الأخطاء الوحدوية (MLWE).

| المعامل | ML-KEM-512 | ML-KEM-768 | ML-KEM-1024 |
|-----------|-----------|-----------|------------|
| المفتاح العام (ek) | 800 bytes | **1,184 bytes** | 1,568 bytes |
| النص المشفر (ct) | 768 bytes | **1,088 bytes** | 1,568 bytes |
| السر المشترك | 32 bytes | 32 bytes | 32 bytes |
| فئة NIST | 1 (128 بت) | **3 (192 بت)** | 5 (256 بت) |

**ML-KEM-768** هو الاختيار الموصى به — وهو مجموعة المعاملات المستخدمة في X-Wing و Signal's PQXDH و تبادل المفاتيح الهجين في Chrome/Firefox TLS. الفئة 3 توفر هامشاً مريحاً ضد التقدم المستقبلي في تحليل شفرات الشبكات.

### كيف يعمل النظام الهجين

**التدفق الحالي (معرض):**

```text
Sender:
  esk = PRF(rseed, rho)                    // deterministic from note
  epk = [esk] * g_d                         // Pallas curve point
  shared_secret = [esk] * pk_d              // ECDH (broken by Shor's)
  K_enc = BLAKE2b("Zcash_OrchardKDF", shared_secret || epk)
  enc_ciphertext = ChaCha20(K_enc, note_plaintext)
```

**التدفق الهجين (مقاوم للكم):**

```text
Sender:
  esk = PRF(rseed, rho)                    // unchanged
  epk = [esk] * g_d                         // unchanged
  ss_ecdh = [esk] * pk_d                    // same ECDH

  (ct_pq, ss_pq) = ML-KEM-768.Encaps(ek_pq)  // NEW: lattice-based KEM
                                                // ek_pq from recipient's address

  K_enc = BLAKE2b(                          // MODIFIED: combines both secrets
      "DashPlatform_HybridKDF",
      ss_ecdh || ss_pq || ct_pq || epk
  )

  enc_ciphertext = ChaCha20(K_enc, note_plaintext)  // unchanged
```

**فك التشفير من المستلم:**

```text
Recipient:
  ss_ecdh = [ivk] * epk                    // same ECDH (using incoming viewing key)
  ss_pq = ML-KEM-768.Decaps(dk_pq, ct_pq)  // NEW: KEM decapsulation
  K_enc = BLAKE2b("DashPlatform_HybridKDF", ss_ecdh || ss_pq || ct_pq || epk)
  note_plaintext = ChaCha20.Decrypt(K_enc, enc_ciphertext)
```

### ضمان الأمان

الـ KEM المدمج آمن IND-CCA2 إذا كان **أي** من مكوني KEM آمناً. هذا مُثبت رسمياً من قبل [Giacon, Heuer, and Poettering (2018)](https://eprint.iacr.org/2018/024) لمُدمجات KEM باستخدام PRF (BLAKE2b مؤهل)، ومُثبت بشكل مستقل من قبل [إثبات أمان X-Wing](https://eprint.iacr.org/2024/039).

| السيناريو | ECDH | ML-KEM | المفتاح المدمج | الحالة |
|----------|------|--------|-------------|--------|
| العالم الكلاسيكي | آمن | آمن | **آمن** | كلاهما سليم |
| الكم يكسر ECC | **مكسور** | آمن | **آمن** | ML-KEM يحمي |
| تقدم الشبكات يكسر ML-KEM | آمن | **مكسور** | **آمن** | ECDH يحمي (مثل اليوم) |
| كلاهما مكسور | مكسور | مكسور | **مكسور** | يتطلب اختراقين متزامنين |

### تأثير الحجم

يضيف KEM الهجين نص ML-KEM-768 المشفر (1,088 bytes) لكل ملاحظة مخزنة ويوسع النص المشفر الصادر ليشمل السر المشترك لـ ML-KEM لاسترداد المرسل:

**السجل المخزن لكل ملاحظة:**

```text
┌──────────────────────────────────────────────────────────────────┐
│  Current (280 bytes)         Hybrid (1,400 bytes)               │
│                                                                  │
│  cmx:             32         cmx:              32               │
│  rho:             32         rho:              32               │
│  epk:             32         epk:              32               │
│  enc_ciphertext: 104         ct_pq:         1,088  ← NEW       │
│  out_ciphertext:  80         enc_ciphertext:  104               │
│                              out_ciphertext:  112  ← +32        │
│  ─────────────────           ──────────────────────             │
│  Total:          280         Total:          1,400  (5.0x)      │
└──────────────────────────────────────────────────────────────────┘
```

**التخزين على نطاق واسع:**

| عدد الملاحظات | الحالي (280 B) | الهجين (1,400 B) | الفرق |
|-------|----------------|------------------|-------|
| 100,000 | 26.7 MB | 133 MB | +106 MB |
| 1,000,000 | 267 MB | 1.33 GB | +1.07 GB |
| 10,000,000 | 2.67 GB | 13.3 GB | +10.7 GB |

**حجم العنوان:**

```text
Current:  diversifier (11) + pk_d (32) = 43 bytes
Hybrid:   diversifier (11) + pk_d (32) + ek_pq (1,184) = 1,227 bytes
```

يجب تضمين المفتاح العام لـ ML-KEM بحجم 1,184 byte في العنوان حتى يتمكن المرسلون من إجراء التغليف. بحوالي 1,960 حرف Bech32m، هذا كبير لكنه لا يزال يناسب رمز QR (بحد أقصى ~2,953 حرف أبجدي رقمي).

### إدارة المفاتيح

يُشتق زوج مفاتيح ML-KEM بشكل حتمي من مفتاح الإنفاق:

```text
SpendingKey (sk) [32 bytes]
  |
  +-> ... (all existing Orchard key derivation unchanged)
  |
  +-> ml_kem_d = PRF^expand(sk, [0x09])[0..32]
  +-> ml_kem_z = PRF^expand(sk, [0x0A])[0..32]
        |
        +-> (ek_pq, dk_pq) = ML-KEM-768.KeyGen(d=ml_kem_d, z=ml_kem_z)
              ek_pq: 1,184 bytes (public, included in address)
              dk_pq: 2,400 bytes (private, part of viewing key)
```

**لا حاجة لتغيير النسخ الاحتياطي.** عبارة البذور المكونة من 24 كلمة الحالية تغطي مفتاح ML-KEM لأنه يُشتق من مفتاح الإنفاق بشكل حتمي. استرداد المحفظة يعمل كما كان.

**العناوين المتنوعة** تشترك جميعها في نفس `ek_pq` لأن ML-KEM ليس لديه آلية تنويع طبيعية مثل ضرب عدد Pallas. هذا يعني أن المراقب الذي يمتلك عنوانين للمستخدم يمكنه ربطهما بمقارنة `ek_pq`.

### أداء فك التشفير التجريبي

| الخطوة | الحالي | الهجين | الفرق |
|------|---------|--------|-------|
| Pallas ECDH | ~100 us | ~100 us | — |
| ML-KEM-768 Decaps | — | ~40 us | +40 us |
| BLAKE2b KDF | ~0.5 us | ~1 us | — |
| ChaCha20 (52 bytes) | ~0.1 us | ~0.1 us | — |
| **المجموع لكل ملاحظة** | **~101 us** | **~141 us** | **+40% حمل إضافي** |

فحص 100,000 ملاحظة: ~10.1 ثانية → ~14.1 ثانية. الحمل الإضافي ملموس لكنه ليس مانعاً. فك تغليف ML-KEM يعمل بزمن ثابت بدون ميزة التجميع (على عكس عمليات المنحنى الإهليلجي)، لذا يتوسع خطياً.

### التأثير على دوائر ZK

**لا يوجد.** KEM الهجين بالكامل في طبقة النقل/التشفير. دائرة Halo 2 تُثبت وجود الملاحظة، صحة المُبطِل، وتوازن القيمة — لا تُثبت شيئاً عن التشفير. لا تغييرات على مفاتيح الإثبات أو مفاتيح التحقق أو قيود الدائرة.

### المقارنة مع الصناعة

| النظام | النهج | الحالة |
|--------|----------|--------|
| **Signal** (PQXDH) | X25519 + ML-KEM-768، إلزامي لجميع المستخدمين | **منشور** (2023) |
| **Chrome/Firefox TLS** | X25519 + ML-KEM-768 تبادل مفاتيح هجين | **منشور** (2024) |
| **X-Wing** (مسودة IETF) | X25519 + ML-KEM-768، مُدمج مُخصص | مسودة معيار |
| **Zcash** | مسودة ZIP للاسترداد الكمي (استرداد الأموال، ليس التشفير) | نقاش فقط |
| **Dash Platform** | Pallas ECDH + ML-KEM-768 (مقترح) | مرحلة التصميم |

## متى يتم النشر

### سؤال الجدول الزمني

- **الحالة الحالية (2026):** لا يوجد حاسوب كمي يمكنه كسر ECC بطول 255 بت. أكبر تحليل كمي مُثبت: ~50 بت. الفجوة: رتب من حيث الحجم.
- **المدى القريب (2030-2035):** خارطات الطريق من IBM و Google و Quantinuum تستهدف ملايين الكيوبتات. تطبيقات ML-KEM ومجموعات المعاملات ستكون قد نضجت.
- **المدى المتوسط (2035-2050):** معظم التقديرات تضع وصول CRQC في هذه النافذة. بيانات HNDL المجمعة اليوم معرضة للخطر.
- **المدى البعيد (2050+):** إجماع بين خبراء التشفير: الحواسيب الكمية واسعة النطاق مسألة "متى" وليس "هل".

### الاستراتيجية الموصى بها

**1. صمم للترقية الآن.** تأكد من أن تنسيق السجل المخزن، وهيكل `TransmittedNoteCiphertext`، وتخطيط إدخال BulkAppendTree مُنسَّخة وقابلة للتوسيع. هذا منخفض التكلفة ويحافظ على خيار إضافة KEM الهجين لاحقاً.

**2. انشر KEM الهجين عند الجاهزية، واجعله إلزامياً.** لا تقدم مجمعين (كلاسيكي وهجين). تقسيم مجموعة إخفاء الهوية يهزم الغرض من المعاملات المحمية — المستخدمون المختبئون في مجموعة أصغر أقل خصوصية، لا أكثر. عند النشر، كل ملاحظة تستخدم النظام الهجين.

**3. استهدف نافذة 2028-2030.** هذا قبل أي تهديد كمي واقعي بكثير لكن بعد استقرار تطبيقات ML-KEM وأحجام المعاملات. كما يسمح بالتعلم من تجربة نشر Zcash و Signal.

**4. راقب الأحداث المحفزة:**
- NIST أو NSA تفرض مواعيد نهائية لترحيل ما بعد الكم
- تقدم كبير في عتاد الكم (>100,000 كيوبت فيزيائي مع تصحيح الأخطاء)
- تقدم في تحليل شفرات مسائل الشبكات (سيؤثر على اختيار ML-KEM)

### ما لا يحتاج لإجراء عاجل

| المكون | لماذا يمكن الانتظار |
|-----------|----------------|
| توقيعات تفويض الإنفاق | التزوير آني وليس بأثر رجعي. الترقية إلى ML-DSA/SLH-DSA قبل وصول CRQC. |
| نظام إثبات Halo 2 | تزوير الإثباتات آني. الترحيل إلى نظام قائم على STARK عند الحاجة. |
| مقاومة تصادم Sinsemilla | مفيد فقط للهجمات الجديدة، ليس بأثر رجعي. مشمول في ترحيل نظام الإثبات. |
| بنية GroveDB التحتية Merk/MMR/Blake3 | **آمنة كمياً بالفعل.** لا حاجة لإجراء، الآن أو أبداً. |

## مرجع بدائل ما بعد الكم

### للتشفير (استبدال ECDH)

| النظام | النوع | المفتاح العام | النص المشفر | فئة NIST | ملاحظات |
|--------|------|-----------|-----------|---------------|-------|
| ML-KEM-768 | Lattice (MLWE) | 1,184 B | 1,088 B | 3 (192 بت) | FIPS 203، معيار الصناعة |
| ML-KEM-512 | Lattice (MLWE) | 800 B | 768 B | 1 (128 بت) | أصغر، هامش أقل |
| ML-KEM-1024 | Lattice (MLWE) | 1,568 B | 1,568 B | 5 (256 بت) | مبالغ للهجين |

### للتوقيعات (استبدال RedPallas/Schnorr)

| النظام | النوع | المفتاح العام | التوقيع | فئة NIST | ملاحظات |
|--------|------|-----------|----------|---------------|-------|
| ML-DSA-65 (Dilithium) | Lattice | 1,952 B | 3,293 B | 3 | FIPS 204، سريع |
| SLH-DSA (SPHINCS+) | Hash-based | 32-64 B | 7,856-49,856 B | 1-5 | FIPS 205، محافظ |
| XMSS/LMS | Hash-based (stateful) | 60 B | 2,500 B | varies | ذو حالة — إعادة الاستخدام = كسر |

### لإثباتات ZK (استبدال Halo 2)

| النظام | الافتراض | حجم الإثبات | ما بعد الكم | ملاحظات |
|--------|-----------|-----------|-------------|-------|
| STARKs | دوال التجزئة (مقاومة التصادم) | ~100-400 KB | **Yes** | مستخدم في StarkNet |
| Plonky3 | FRI (التزام متعدد الحدود قائم على التجزئة) | ~50-200 KB | **Yes** | تطوير نشط |
| Halo 2 (الحالي) | ECDLP على منحنيات Pasta | ~5 KB | **No** | نظام Orchard الحالي |
| Lattice SNARKs | MLWE | بحثي | **Yes** | غير جاهز للإنتاج |

### نظام حزم Rust البيئي

| الحزمة | المصدر | FIPS 203 | مُتحقق | ملاحظات |
|-------|--------|----------|----------|-------|
| `libcrux-ml-kem` | Cryspen | Yes | مُتحقق رسمياً (hax/F*) | أعلى ضمان |
| `ml-kem` | RustCrypto | Yes | زمن ثابت، غير مُراجع | توافق النظام البيئي |
| `fips203` | integritychain | Yes | زمن ثابت | Rust نقي، no_std |

## الملخص

```text
┌─────────────────────────────────────────────────────────────────────┐
│  QUANTUM THREAT SUMMARY FOR GROVEDB + ORCHARD                      │
│                                                                     │
│  SAFE NOW AND FOREVER (hash-based):                                 │
│    ✓ Blake3 Merk trees, MMR, BulkAppendTree                        │
│    ✓ BLAKE2b KDF, PRF^expand                                       │
│    ✓ ChaCha20-Poly1305 symmetric encryption                        │
│    ✓ All GroveDB proof authentication chains                        │
│                                                                     │
│  FIX BEFORE DATA IS STORED (retroactive HNDL):                     │
│    ✗ Note encryption (ECDH key agreement) → Hybrid KEM             │
│    ✗ Value commitments (Pedersen) → amounts revealed                │
│                                                                     │
│  FIX BEFORE QUANTUM COMPUTERS ARRIVE (real-time only):              │
│    ~ Spend authorization → ML-DSA / SLH-DSA                        │
│    ~ ZK proofs → STARKs / Plonky3                                  │
│    ~ Sinsemilla → hash-based Merkle tree                            │
│                                                                     │
│  RECOMMENDED TIMELINE:                                              │
│    2026-2028: Design for upgradability, version stored formats      │
│    2028-2030: Deploy mandatory hybrid KEM for note encryption       │
│    2035+: Migrate signatures and proof system if needed             │
└─────────────────────────────────────────────────────────────────────┘
```

---
