# 양자 암호학 -- 포스트 양자 위협 분석

이 장에서는 양자 컴퓨터가 GroveDB에서 사용되는 암호학적 기본 요소와 그 위에 구축된 차폐 트랜잭션 프로토콜(Orchard, Dash Platform)에 어떤 영향을 미치는지 분석합니다. 어떤 구성 요소가 취약하고 어떤 것이 안전한지, "지금 수확하고 나중에 복호화(harvest now, decrypt later)"가 저장된 데이터에 어떤 의미를 갖는지, 그리고 하이브리드 KEM 설계를 포함한 어떤 완화 전략이 존재하는지 다룹니다.

## 중요한 두 가지 양자 알고리즘

암호학에서 실질적으로 관련된 양자 알고리즘은 두 가지뿐입니다:

**Shor 알고리즘**은 이산 로그 문제(및 정수 인수분해)를 다항 시간에 풉니다. Pallas와 같은 255비트 타원 곡선의 경우 대략 510개의 논리 큐비트가 필요하지만, 오류 정정 오버헤드를 고려하면 실제 요구 사항은 약 400만 개의 물리적 큐비트입니다. Shor 알고리즘은 키 크기에 관계없이 모든 타원 곡선 암호를 **완전히 파괴**합니다.

**Grover 알고리즘**은 무차별 대입 검색에 대해 이차 속도 향상을 제공합니다. 256비트 대칭 키는 사실상 128비트가 됩니다. 그러나 128비트 키 공간에 대한 Grover 회로 깊이는 여전히 2^64 양자 연산이며, 많은 암호학자들은 디코히어런스 한계로 인해 실제 하드웨어에서는 결코 실용적이지 않을 것이라고 믿습니다. Grover는 보안 마진을 줄이지만 잘 매개변수화된 대칭 암호를 깨뜨리지는 않습니다.

| 알고리즘 | 대상 | 속도 향상 | 실질적 영향 |
|-----------|---------|---------|------------------|
| **Shor** | ECC 이산 로그, RSA 인수분해 | 다항 시간 (고전 대비 지수적 가속) | ECC **완전 파괴** |
| **Grover** | 대칭 키 검색, 해시 프리이미지 | 이차 (키 비트 반감) | 256비트 -> 128비트 (여전히 안전) |

## GroveDB의 암호학적 기본 요소

GroveDB와 Orchard 기반 차폐 프로토콜은 타원 곡선과 대칭/해시 기반 기본 요소를 혼합하여 사용합니다. 아래 표는 양자 취약성에 따라 모든 기본 요소를 분류합니다:

### 양자 취약 (Shor 알고리즘 -- 포스트 양자 0비트)

| 기본 요소 | 사용 위치 | 무엇이 깨지는가 |
|-----------|-----------|-------------|
| **Pallas ECDLP** | 노트 커밋먼트(cmx), 임시 키(epk/esk), 보기 키(ivk), 지불 키(pk_d), 널리파이어 유도 | 공개 대응물로부터 모든 개인 키 복구 |
| **ECDH 키 합의** (Pallas) | 노트 암호문에 대한 대칭 암호화 키 유도 | 공유 비밀 복구 -> 모든 노트 복호화 |
| **Sinsemilla 해시** | CommitmentTree 머클 경로, 회로 내 해싱 | 충돌 저항성이 ECDLP에 의존; Pallas가 깨지면 약화 |
| **Halo 2 IPA** | ZK 증명 시스템 (Pasta 곡선 위의 다항식 커밋먼트) | 거짓 명제에 대한 증명 위조 (위조, 무단 지출) |
| **Pedersen 커밋먼트** | 트랜잭션 금액을 숨기는 가치 커밋먼트(cv_net) | 숨겨진 금액 복구; 잔액 증명 위조 |

### 양자 안전 (Grover 알고리즘 -- 포스트 양자 128비트 이상)

| 기본 요소 | 사용 위치 | 포스트 양자 보안 |
|-----------|-----------|----------------------|
| **Blake3** | Merk 트리 노드 해시, MMR 노드, BulkAppendTree 상태 루트, 서브트리 경로 접두사 | 128비트 프리이미지, 128비트 제2프리이미지 |
| **BLAKE2b-256** | 대칭 키 유도를 위한 KDF, 발신 암호 키, PRF^expand | 128비트 프리이미지 |
| **ChaCha20-Poly1305** | enc_ciphertext 및 out_ciphertext 암호화 (256비트 키) | 128비트 키 검색 (안전하지만, ECDH를 통한 키 유도 경로는 안전하지 않음) |
| **PRF^expand** (BLAKE2b-512) | rseed에서 esk, rcm, psi 유도 | 128비트 PRF 보안 |

### GroveDB 인프라: 현재 가정 하에 양자 안전으로 간주

GroveDB의 자체 데이터 구조는 전적으로 Blake3 해싱에 의존합니다:

- **Merk AVL 트리** -- 노드 해시, combined_value_hash, 자식 해시 전파
- **MMR 트리** -- 내부 노드 해시, 피크 계산, 루트 유도
- **BulkAppendTree** -- 버퍼 해시 체인, 밀집 머클 루트, 에포크 MMR
- **CommitmentTree 상태 루트** -- `blake3("ct_state" || sinsemilla_root || bulk_state_root)`
- **서브트리 경로 접두사** -- 경로 세그먼트의 Blake3 해싱
- **V1 증명** -- Merk 계층 구조를 통한 인증 체인

**현재 변경이 필요하지 않습니다.** GroveDB의 Merk 트리 증명, MMR 일관성 검사, BulkAppendTree 에포크 루트 및 모든 V1 증명 인증 체인은 현재 가정 하에서 양자 컴퓨터에 대해 안전한 것으로 간주됩니다. 해시 기반 인프라는 포스트 양자에서 시스템의 가장 강력한 부분입니다.

## 소급적 위협 vs 실시간 위협

이 구분은 무엇을 언제 수정해야 하는지 우선순위를 정하는 데 매우 중요합니다.

**소급적 위협**은 이미 저장된 데이터를 손상시킵니다. 공격자는 오늘 데이터를 기록하고 양자 컴퓨터가 사용 가능해지면 복호화합니다. 이러한 위협은 **사후에 완화할 수 없습니다** -- 데이터가 온체인에 있으면 재암호화하거나 회수할 수 없습니다.

**실시간 위협**은 미래에 생성되는 트랜잭션에만 영향을 미칩니다. 양자 컴퓨터를 가진 공격자가 서명이나 증명을 위조할 수 있지만, 새로운 트랜잭션에 대해서만 가능합니다. 이전 트랜잭션은 이미 네트워크에 의해 검증되고 확인되었습니다.

| 위협 | 유형 | 노출되는 것 | 긴급성 |
|--------|------|---------------|---------|
| **노트 복호화** (enc_ciphertext) | **소급적** | 노트 내용: 수신자, 금액, 메모, rseed | **높음** -- 영구 저장 |
| **가치 커밋먼트 개방** (cv_net) | **소급적** | 트랜잭션 금액 (발신자/수신자는 아님) | **중간** -- 금액만 |
| **발신자 복구 데이터** (out_ciphertext) | **소급적** | 보낸 노트에 대한 발신자의 복구 키 | **높음** -- 영구 저장 |
| 지출 인증 위조 | 실시간 | 새로운 지출 서명 위조 가능 | 낮음 -- QC 도착 전 업그레이드 |
| Halo 2 증명 위조 | 실시간 | 새로운 증명 위조 가능 (위조) | 낮음 -- QC 도착 전 업그레이드 |
| Sinsemilla 충돌 | 실시간 | 새로운 머클 경로 위조 가능 | 낮음 -- 증명 위조에 포함됨 |
| 바인딩 서명 위조 | 실시간 | 새로운 잔액 증명 위조 가능 | 낮음 -- QC 도착 전 업그레이드 |

### 정확히 무엇이 드러나는가?

**노트 암호화가 깨지면** (주요 HNDL 위협):

양자 공격자는 Shor 알고리즘을 통해 저장된 `epk`에서 `esk`를 복구하고, ECDH 공유 비밀을 계산하고, 대칭 키를 유도한 다음 `enc_ciphertext`를 복호화합니다. 이는 전체 노트 평문을 드러냅니다:

| 필드 | 크기 | 드러나는 것 |
|-------|------|----------------|
| version | 1 byte | 프로토콜 버전 (민감하지 않음) |
| diversifier | 11 bytes | 수신자의 주소 구성 요소 |
| value | 8 bytes | 정확한 트랜잭션 금액 |
| rseed | 32 bytes | 널리파이어 연결 가능 (트랜잭션 그래프 비익명화) |
| memo | 36 bytes (DashMemo) | 애플리케이션 데이터, 잠재적으로 식별 가능 |

`rseed`와 `rho`(암호문과 함께 저장됨)를 사용하면 공격자는 `esk = PRF(rseed, rho)`를 계산하고 임시 키 바인딩을 확인할 수 있습니다. diversifier와 결합하면 전체 트랜잭션 기록에 걸쳐 입력과 출력을 연결합니다 -- **차폐 풀의 완전한 비익명화**.

**가치 커밋먼트만 깨지면** (이차 HNDL 위협):

공격자는 ECDLP를 풀어 `cv_net = [v]*V + [rcv]*R`에서 `v`를 복구합니다. 이는 **트랜잭션 금액은 드러나지만 발신자나 수신자의 신원은 드러나지 않습니다**. 공격자는 "누군가가 누군가에게 5.0 Dash를 보냈다"는 것을 볼 수 있지만, 노트 암호화도 깨지지 않으면 금액을 어떤 주소나 신원에도 연결할 수 없습니다.

자체적으로 연결 없는 금액은 유용성이 제한됩니다. 그러나 외부 데이터(타이밍, 알려진 송장, 공개 요청과 일치하는 금액)와 결합하면 상관 공격이 가능해집니다.

## "지금 수확, 나중에 복호화" 공격

이것은 가장 긴급하고 실용적인 양자 위협입니다.

**공격 모델:** 국가 수준의 공격자(또는 충분한 저장 공간을 가진 모든 당사자)가 오늘 온체인의 모든 차폐 트랜잭션 데이터를 기록합니다. 이 데이터는 블록체인에서 공개적으로 사용 가능하며 불변입니다. 공격자는 암호학적으로 관련된 양자 컴퓨터(CRQC)를 기다린 다음:

```text
Step 1: Read stored record from CommitmentTree BulkAppendTree:
        cmx (32) || rho (32) || epk (32) || enc_ciphertext (104) || out_ciphertext (80)

Step 2: Solve ECDLP on Pallas via Shor's algorithm:
        epk = [esk] * g_d  →  recover esk

Step 3: Compute shared secret:
        shared_secret = [esk] * pk_d

Step 4: Derive symmetric key (BLAKE2b is quantum-safe, but input is compromised):
        K_enc = BLAKE2b-256("Zcash_OrchardKDF", shared_secret || epk)

Step 5: Decrypt enc_ciphertext using ChaCha20-Poly1305:
        → version || diversifier || value || rseed || memo

Step 6: With rseed + rho, link nullifiers to note commitments:
        esk = PRF(rseed, rho)
        → full transaction graph reconstruction
```

**핵심 통찰:** 대칭 암호화(ChaCha20-Poly1305)는 완벽하게 양자 안전합니다. 취약점은 전적으로 **키 유도 경로**에 있습니다 -- 대칭 키는 ECDH 공유 비밀에서 유도되고, ECDH는 Shor 알고리즘에 의해 깨집니다. 공격자는 암호화를 깨는 것이 아니라 키를 복구합니다.

**소급성:** 이 공격은 **완전히 소급적**입니다. CRQC가 존재하면 온체인에 저장된 모든 암호화된 노트를 복호화할 수 있습니다. 데이터는 사후에 재암호화하거나 보호할 수 없습니다. 이것이 데이터가 저장되기 전에, 이후가 아니라 해결해야 하는 이유입니다.

## 완화: 하이브리드 KEM (ML-KEM + ECDH)

HNDL에 대한 방어는 **두 개의 독립적인 키 합의 메커니즘**에서 대칭 암호화 키를 유도하여, 하나만 깨는 것으로는 충분하지 않게 하는 것입니다. 이것을 하이브리드 KEM이라고 합니다.

### ML-KEM-768 (CRYSTALS-Kyber)

ML-KEM은 모듈 오류가 있는 학습(MLWE) 문제를 기반으로 한 NIST 표준화(FIPS 203, 2024년 8월) 포스트 양자 키 캡슐화 메커니즘입니다.

| 매개변수 | ML-KEM-512 | ML-KEM-768 | ML-KEM-1024 |
|-----------|-----------|-----------|------------|
| 공개 키 (ek) | 800 bytes | **1,184 bytes** | 1,568 bytes |
| 암호문 (ct) | 768 bytes | **1,088 bytes** | 1,568 bytes |
| 공유 비밀 | 32 bytes | 32 bytes | 32 bytes |
| NIST 범주 | 1 (128비트) | **3 (192비트)** | 5 (256비트) |

**ML-KEM-768**이 권장 선택입니다 -- X-Wing, Signal의 PQXDH, Chrome/Firefox TLS 하이브리드 키 교환에서 사용되는 매개변수 세트입니다. 범주 3은 미래 격자 암호 분석 발전에 대해 편안한 여유를 제공합니다.

### 하이브리드 방식의 작동 원리

**현재 흐름 (취약):**

```text
Sender:
  esk = PRF(rseed, rho)                    // deterministic from note
  epk = [esk] * g_d                         // Pallas curve point
  shared_secret = [esk] * pk_d              // ECDH (broken by Shor's)
  K_enc = BLAKE2b("Zcash_OrchardKDF", shared_secret || epk)
  enc_ciphertext = ChaCha20(K_enc, note_plaintext)
```

**하이브리드 흐름 (양자 저항):**

```text
Sender:
  esk = PRF(rseed, rho)                    // unchanged
  epk = [esk] * g_d                         // unchanged
  ss_ecdh = [esk] * pk_d                    // same ECDH

  (ct_pq, ss_pq) = ML-KEM-768.Encaps(ek_pq)  // NEW: lattice-based KEM
                                                // ek_pq from recipient's address

  K_enc = BLAKE2b(                          // MODIFIED: combines both secrets
      "DashPlatform_HybridKDF",
      ss_ecdh || ss_pq || ct_pq || epk
  )

  enc_ciphertext = ChaCha20(K_enc, note_plaintext)  // unchanged
```

**수신자 복호화:**

```text
Recipient:
  ss_ecdh = [ivk] * epk                    // same ECDH (using incoming viewing key)
  ss_pq = ML-KEM-768.Decaps(dk_pq, ct_pq)  // NEW: KEM decapsulation
  K_enc = BLAKE2b("DashPlatform_HybridKDF", ss_ecdh || ss_pq || ct_pq || epk)
  note_plaintext = ChaCha20.Decrypt(K_enc, enc_ciphertext)
```

### 보안 보장

결합된 KEM은 **어느 한쪽** 구성 요소 KEM이 안전하면 IND-CCA2 보안을 갖습니다. 이는 PRF(BLAKE2b가 해당)를 사용하는 KEM 결합기에 대해 [Giacon, Heuer, and Poettering (2018)](https://eprint.iacr.org/2018/024)에 의해 형식적으로 증명되었으며, [X-Wing 보안 증명](https://eprint.iacr.org/2024/039)에 의해 독립적으로 증명되었습니다.

| 시나리오 | ECDH | ML-KEM | 결합 키 | 상태 |
|----------|------|--------|-------------|--------|
| 고전 세계 | 안전 | 안전 | **안전** | 둘 다 무결 |
| 양자가 ECC를 깨뜨림 | **깨짐** | 안전 | **안전** | ML-KEM이 보호 |
| 격자 발전이 ML-KEM을 깨뜨림 | 안전 | **깨짐** | **안전** | ECDH가 보호 (현재와 동일) |
| 둘 다 깨짐 | 깨짐 | 깨짐 | **깨짐** | 두 가지 동시 돌파 필요 |

### 크기 영향

하이브리드 KEM은 ML-KEM-768 암호문(1,088 bytes)을 저장된 각 노트에 추가하고, 발신자 복구를 위해 ML-KEM 공유 비밀을 포함하도록 발신 암호문을 확장합니다:

**노트당 저장 레코드:**

```text
┌──────────────────────────────────────────────────────────────────┐
│  Current (280 bytes)         Hybrid (1,400 bytes)               │
│                                                                  │
│  cmx:             32         cmx:              32               │
│  rho:             32         rho:              32               │
│  epk:             32         epk:              32               │
│  enc_ciphertext: 104         ct_pq:         1,088  ← NEW       │
│  out_ciphertext:  80         enc_ciphertext:  104               │
│                              out_ciphertext:  112  ← +32        │
│  ─────────────────           ──────────────────────             │
│  Total:          280         Total:          1,400  (5.0x)      │
└──────────────────────────────────────────────────────────────────┘
```

**규모별 저장:**

| 노트 수 | 현재 (280 B) | 하이브리드 (1,400 B) | 차이 |
|-------|----------------|------------------|-------|
| 100,000 | 26.7 MB | 133 MB | +106 MB |
| 1,000,000 | 267 MB | 1.33 GB | +1.07 GB |
| 10,000,000 | 2.67 GB | 13.3 GB | +10.7 GB |

**주소 크기:**

```text
Current:  diversifier (11) + pk_d (32) = 43 bytes
Hybrid:   diversifier (11) + pk_d (32) + ek_pq (1,184) = 1,227 bytes
```

1,184 byte ML-KEM 공개 키는 발신자가 캡슐화를 수행할 수 있도록 주소에 포함되어야 합니다. 약 1,960 Bech32m 문자로, 크기가 크지만 QR 코드(최대 약 2,953개 영숫자 문자)에 여전히 적합합니다.

### 키 관리

ML-KEM 키 쌍은 지출 키에서 결정적으로 유도됩니다:

```text
SpendingKey (sk) [32 bytes]
  |
  +-> ... (all existing Orchard key derivation unchanged)
  |
  +-> ml_kem_d = PRF^expand(sk, [0x09])[0..32]
  +-> ml_kem_z = PRF^expand(sk, [0x0A])[0..32]
        |
        +-> (ek_pq, dk_pq) = ML-KEM-768.KeyGen(d=ml_kem_d, z=ml_kem_z)
              ek_pq: 1,184 bytes (public, included in address)
              dk_pq: 2,400 bytes (private, part of viewing key)
```

**백업 변경 불필요.** 기존 24단어 시드 구문이 ML-KEM 키를 포함합니다. 지출 키에서 결정적으로 유도되기 때문입니다. 지갑 복구는 이전과 동일하게 작동합니다.

**다양화된 주소**는 ML-KEM에 Pallas 스칼라 곱셈과 같은 자연스러운 다양화 메커니즘이 없기 때문에 동일한 `ek_pq`를 공유합니다. 이는 사용자의 두 주소를 가진 관찰자가 `ek_pq`를 비교하여 연결할 수 있음을 의미합니다.

### 시행 복호화 성능

| 단계 | 현재 | 하이브리드 | 차이 |
|------|---------|--------|-------|
| Pallas ECDH | ~100 us | ~100 us | -- |
| ML-KEM-768 Decaps | -- | ~40 us | +40 us |
| BLAKE2b KDF | ~0.5 us | ~1 us | -- |
| ChaCha20 (52 bytes) | ~0.1 us | ~0.1 us | -- |
| **노트당 합계** | **~101 us** | **~141 us** | **+40% 오버헤드** |

100,000개 노트 스캔: ~10.1초 -> ~14.1초. 오버헤드는 의미 있지만 금지적이지 않습니다. ML-KEM 역캡슐화는 (타원 곡선 연산과 달리) 배칭 이점 없는 상수 시간이므로 선형적으로 확장됩니다.

### ZK 회로에 대한 영향

**없음.** 하이브리드 KEM은 전적으로 전송/암호화 레이어에 있습니다. Halo 2 회로는 노트 존재, 널리파이어 정확성 및 가치 균형을 증명합니다 -- 암호화에 대해서는 아무것도 증명하지 않습니다. 증명 키, 검증 키 또는 회로 제약에 대한 변경이 없습니다.

### 업계 비교

| 시스템 | 접근 방식 | 상태 |
|--------|----------|--------|
| **Signal** (PQXDH) | X25519 + ML-KEM-768, 모든 사용자에게 필수 | **배포됨** (2023) |
| **Chrome/Firefox TLS** | X25519 + ML-KEM-768 하이브리드 키 교환 | **배포됨** (2024) |
| **X-Wing** (IETF 초안) | X25519 + ML-KEM-768, 전용 결합기 | 초안 표준 |
| **Zcash** | 양자 복구 가능성 초안 ZIP (자금 복구, 암호화 아님) | 논의 중 |
| **Dash Platform** | Pallas ECDH + ML-KEM-768 (제안됨) | 설계 단계 |

## 배포 시기

### 시간표 질문

- **현재 상태 (2026):** 어떤 양자 컴퓨터도 255비트 ECC를 깨뜨릴 수 없습니다. 가장 큰 시연된 양자 인수분해: 약 50비트. 격차: 수 자릿수.
- **단기 (2030-2035):** IBM, Google, Quantinuum의 하드웨어 로드맵은 수백만 큐비트를 목표로 합니다. ML-KEM 구현 및 매개변수 세트가 성숙해질 것입니다.
- **중기 (2035-2050):** 대부분의 추정은 CRQC 도착을 이 기간에 놓습니다. 오늘 수집된 HNDL 데이터가 위험에 처합니다.
- **장기 (2050+):** 암호학자들 사이의 합의: 대규모 양자 컴퓨터는 "만약"이 아니라 "언제"의 문제입니다.

### 권장 전략

**1. 지금 업그레이드 가능성을 위해 설계하세요.** 저장 레코드 형식, `TransmittedNoteCiphertext` 구조체, BulkAppendTree 항목 레이아웃이 버전 관리되고 확장 가능하도록 보장하세요. 이것은 비용이 적게 들고 나중에 하이브리드 KEM을 추가할 수 있는 옵션을 보존합니다.

**2. 준비되면 하이브리드 KEM을 배포하고 필수로 만드세요.** 두 개의 풀(고전 및 하이브리드)을 제공하지 마세요. 익명성 세트를 분할하면 차폐 트랜잭션의 목적이 훼손됩니다 -- 더 작은 그룹에 숨는 사용자는 덜 프라이빗하지, 더 프라이빗하지 않습니다. 배포 시 모든 노트가 하이브리드 방식을 사용합니다.

**3. 2028-2030 기간을 목표로 하세요.** 이것은 현실적인 양자 위협 이전이지만 ML-KEM 구현 및 매개변수 크기가 안정화된 이후입니다. 또한 Zcash와 Signal의 배포 경험에서 배울 수 있습니다.

**4. 트리거 이벤트를 모니터링하세요:**
- NIST 또는 NSA의 포스트 양자 마이그레이션 기한 의무화
- 양자 하드웨어의 중요한 발전 (오류 정정 포함 10만 개 이상의 물리적 큐비트)
- 격자 문제에 대한 암호 분석 발전 (ML-KEM 선택에 영향)

### 긴급 조치가 필요하지 않은 것

| 구성 요소 | 기다릴 수 있는 이유 |
|-----------|----------------|
| 지출 인증 서명 | 위조는 실시간이며 소급적이지 않음. CRQC 도착 전 ML-DSA/SLH-DSA로 업그레이드. |
| Halo 2 증명 시스템 | 증명 위조는 실시간. 필요 시 STARK 기반 시스템으로 마이그레이션. |
| Sinsemilla 충돌 저항성 | 새로운 공격에만 유용하며 소급적이지 않음. 증명 시스템 마이그레이션에 포함됨. |
| GroveDB Merk/MMR/Blake3 인프라 | **현재 가정과 표준 하에서 양자 안전으로 간주됨.** 현재 조치 불필요. |

## 포스트 양자 대안 참조

### 암호화용 (ECDH 대체)

| 방식 | 유형 | 공개 키 | 암호문 | NIST 범주 | 비고 |
|--------|------|-----------|-----------|---------------|-------|
| ML-KEM-768 | Lattice (MLWE) | 1,184 B | 1,088 B | 3 (192비트) | FIPS 203, 업계 표준 |
| ML-KEM-512 | Lattice (MLWE) | 800 B | 768 B | 1 (128비트) | 더 작음, 낮은 마진 |
| ML-KEM-1024 | Lattice (MLWE) | 1,568 B | 1,568 B | 5 (256비트) | 하이브리드에 과잉 |

### 서명용 (RedPallas/Schnorr 대체)

| 방식 | 유형 | 공개 키 | 서명 | NIST 범주 | 비고 |
|--------|------|-----------|----------|---------------|-------|
| ML-DSA-65 (Dilithium) | Lattice | 1,952 B | 3,293 B | 3 | FIPS 204, 빠름 |
| SLH-DSA (SPHINCS+) | Hash-based | 32-64 B | 7,856-49,856 B | 1-5 | FIPS 205, 보수적 |
| XMSS/LMS | Hash-based (stateful) | 60 B | 2,500 B | varies | 상태 보존 -- 재사용 = 파괴 |

### ZK 증명용 (Halo 2 대체)

| 시스템 | 가정 | 증명 크기 | 포스트 양자 | 비고 |
|--------|-----------|-----------|-------------|-------|
| STARKs | 해시 함수 (충돌 저항성) | ~100-400 KB | **Yes** | StarkNet에서 사용 |
| Plonky3 | FRI (해시 기반 다항식 커밋먼트) | ~50-200 KB | **Yes** | 활발한 개발 중 |
| Halo 2 (현재) | Pasta 곡선의 ECDLP | ~5 KB | **No** | 현재 Orchard 시스템 |
| Lattice SNARKs | MLWE | 연구 중 | **Yes** | 프로덕션 준비 안됨 |

### Rust 크레이트 생태계

| 크레이트 | 출처 | FIPS 203 | 검증됨 | 비고 |
|-------|--------|----------|----------|-------|
| `libcrux-ml-kem` | Cryspen | Yes | 형식적으로 검증됨 (hax/F*) | 최고 보증 |
| `ml-kem` | RustCrypto | Yes | 상수 시간, 감사 안됨 | 생태계 호환성 |
| `fips203` | integritychain | Yes | 상수 시간 | 순수 Rust, no_std |

## 요약

```text
┌─────────────────────────────────────────────────────────────────────┐
│  GROVEDB + ORCHARD 양자 위협 요약                                    │
│                                                                     │
│  현재 가정 하에 안전 (해시 기반):                                      │
│    ✓ Blake3 Merk trees, MMR, BulkAppendTree                        │
│    ✓ BLAKE2b KDF, PRF^expand                                       │
│    ✓ ChaCha20-Poly1305 대칭 암호화                                   │
│    ✓ 모든 GroveDB 증명 인증 체인                                      │
│                                                                     │
│  데이터 저장 전 수정 필요 (소급적 HNDL):                                │
│    ✗ 노트 암호화 (ECDH 키 합의) → 하이브리드 KEM                      │
│    ✗ 값 커밋먼트 (Pedersen) → 금액 노출                               │
│                                                                     │
│  양자 컴퓨터 도래 전 수정 필요 (실시간만 해당):                          │
│    ~ 지출 승인 → ML-DSA / SLH-DSA                                   │
│    ~ ZK 증명 → STARKs / Plonky3                                    │
│    ~ Sinsemilla → 해시 기반 머클 트리                                 │
│                                                                     │
│  권장 일정:                                                          │
│    2026-2028: 업그레이드 가능성 설계, 저장 형식 버전 관리              │
│    2028-2030: 노트 암호화를 위한 필수 하이브리드 KEM 배포              │
│    2035+: 필요 시 서명 및 증명 시스템 마이그레이션                     │
└─────────────────────────────────────────────────────────────────────┘
```

---
