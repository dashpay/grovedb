# การเข้ารหัสเชิงควอนตัม — การวิเคราะห์ภัยคุกคามหลังยุคควอนตัม

บทนี้วิเคราะห์ว่าคอมพิวเตอร์ควอนตัมจะส่งผลกระทบต่อพื้นฐานการเข้ารหัส
ที่ใช้ใน GroveDB และโปรโตคอลธุรกรรมแบบปกปิดที่สร้างขึ้นบนนั้น (Orchard,
Dash Platform) อย่างไร บทนี้ครอบคลุมว่าส่วนประกอบใดมีความเสี่ยง ส่วนใดปลอดภัย
"harvest now, decrypt later" หมายความว่าอย่างไรสำหรับข้อมูลที่จัดเก็บ
และกลยุทธ์การบรรเทาผลกระทบที่มีอยู่ — รวมถึงการออกแบบ KEM แบบไฮบริด

## อัลกอริทึมควอนตัมสองตัวที่สำคัญ

มีเพียงสองอัลกอริทึมควอนตัมที่เกี่ยวข้องกับการเข้ารหัสในทางปฏิบัติ:

**อัลกอริทึมของ Shor** แก้ปัญหาลอการิทึมแบบไม่ต่อเนื่อง (และการแยกตัวประกอบ
จำนวนเต็ม) ในเวลาพหุนาม สำหรับเส้นโค้งวงรี 255 บิตอย่าง Pallas ต้องใช้
ประมาณ 510 คิวบิตเชิงตรรกะ — แต่ด้วยค่าใช้จ่ายในการแก้ไขข้อผิดพลาด ความ
ต้องการจริงอยู่ที่ประมาณ 4 ล้านคิวบิตทางกายภาพ อัลกอริทึมของ Shor
**ทำลายได้อย่างสมบูรณ์** การเข้ารหัสเส้นโค้งวงรีทั้งหมดโดยไม่คำนึงถึงขนาดกุญแจ

**อัลกอริทึมของ Grover** ให้ความเร็วเพิ่มขึ้นแบบกำลังสองสำหรับการค้นหาแบบ
brute-force กุญแจสมมาตร 256 บิตจะเทียบเท่ากับ 128 บิตอย่างมีประสิทธิภาพ อย่าง
ไรก็ตาม ความลึกของวงจรสำหรับอัลกอริทึมของ Grover บนพื้นที่กุญแจ 128 บิตยังคง
เป็น 2^64 การดำเนินการควอนตัม — นักเข้ารหัสหลายคนเชื่อว่าสิ่งนี้จะไม่เป็น
จริงได้ในฮาร์ดแวร์จริงเนื่องจากขีดจำกัดของการสูญเสียการเชื่อมโยง อัลกอริทึม
ของ Grover ลดระยะห่างด้านความปลอดภัยแต่ไม่ทำลายการเข้ารหัสสมมาตรที่กำหนด
พารามิเตอร์ได้ดี

| อัลกอริทึม | เป้าหมาย | ความเร็วที่เพิ่มขึ้น | ผลกระทบในทางปฏิบัติ |
|-----------|---------|---------------------|---------------------|
| **Shor** | ECC discrete log, RSA factoring | เวลาพหุนาม (เร็วกว่าแบบคลาสสิกเป็นเลขชี้กำลัง) | **ทำลายได้ทั้งหมด** ของ ECC |
| **Grover** | การค้นหากุญแจสมมาตร, hash preimage | แบบกำลังสอง (ลดบิตกุญแจลงครึ่ง) | 256-bit → 128-bit (ยังปลอดภัย) |

## พื้นฐานการเข้ารหัสของ GroveDB

GroveDB และโปรโตคอลแบบปกปิดที่ใช้ Orchard ใช้ส่วนผสมของพื้นฐานเส้นโค้งวงรี
และสมมาตร/ที่อิงแฮช ตารางด้านล่างจำแนกพื้นฐานแต่ละตัวตามความเสี่ยงด้าน
ควอนตัม:

### เสี่ยงต่อควอนตัม (อัลกอริทึมของ Shor — 0 บิตหลังยุคควอนตัม)

| พื้นฐาน | ที่ใช้งาน | สิ่งที่ถูกทำลาย |
|---------|----------|----------------|
| **Pallas ECDLP** | Note commitments (cmx), ephemeral keys (epk/esk), viewing keys (ivk), payment keys (pk_d), nullifier derivation | กู้คืนกุญแจส่วนตัวใดก็ได้จากคู่สาธารณะ |
| **ECDH key agreement** (Pallas) | สร้างกุญแจเข้ารหัสสมมาตรสำหรับ note ciphertexts | กู้คืน shared secret → ถอดรหัสทุก notes |
| **Sinsemilla hash** | เส้นทาง Merkle ของ CommitmentTree, in-circuit hashing | ความต้านทานการชนขึ้นอยู่กับ ECDLP; ลดลงเมื่อ Pallas ถูกทำลาย |
| **Halo 2 IPA** | ระบบพิสูจน์ ZK (polynomial commitment over Pasta curves) | ปลอมแปลงหลักฐานสำหรับข้อความเท็จ (การปลอม, การใช้จ่ายที่ไม่ได้รับอนุญาต) |
| **Pedersen commitments** | Value commitments (cv_net) ซ่อนจำนวนธุรกรรม | กู้คืนจำนวนที่ซ่อน; ปลอมแปลงหลักฐานยอดคงเหลือ |

### ปลอดภัยจากควอนตัม (อัลกอริทึมของ Grover — 128+ บิตหลังยุคควอนตัม)

| พื้นฐาน | ที่ใช้งาน | ความปลอดภัยหลังยุคควอนตัม |
|---------|----------|--------------------------|
| **Blake3** | แฮชโหนด Merk tree, MMR nodes, BulkAppendTree state roots, subtree path prefixes | 128-bit preimage, 128-bit second-preimage |
| **BLAKE2b-256** | KDF สำหรับการสร้างกุญแจสมมาตร, outgoing cipher key, PRF^expand | 128-bit preimage |
| **ChaCha20-Poly1305** | เข้ารหัส enc_ciphertext และ out_ciphertext (กุญแจ 256-bit) | 128-bit key search (ปลอดภัย แต่เส้นทางการสร้างกุญแจผ่าน ECDH ไม่ปลอดภัย) |
| **PRF^expand** (BLAKE2b-512) | สร้าง esk, rcm, psi จาก rseed | 128-bit PRF security |

### โครงสร้างพื้นฐาน GroveDB: ถือว่าปลอดภัยจากควอนตัมภายใต้สมมติฐานปัจจุบัน

โครงสร้างข้อมูลทั้งหมดของ GroveDB อาศัยการแฮช Blake3 โดยเฉพาะ:

- **Merk AVL trees** — แฮชโหนด, combined_value_hash, การส่งต่อ child hash
- **MMR trees** — แฮชโหนดภายใน, การคำนวณยอด, การสร้าง root
- **BulkAppendTree** — ห่วงโซ่แฮชบัฟเฟอร์, dense Merkle roots, epoch MMR
- **CommitmentTree state root** — `blake3("ct_state" || sinsemilla_root || bulk_state_root)`
- **Subtree path prefixes** — การแฮช Blake3 ของส่วนเส้นทาง
- **V1 proofs** — ห่วงโซ่การยืนยันตัวตนผ่านลำดับชั้น Merk

**ไม่จำเป็นต้องเปลี่ยนแปลงในขณะนี้** หลักฐาน Merk tree ของ GroveDB, การ
ตรวจสอบความสอดคล้อง MMR, root epoch ของ BulkAppendTree และห่วงโซ่การยืนยัน
ตัวตนหลักฐาน V1 ทั้งหมดถือว่าปลอดภัยจากคอมพิวเตอร์ควอนตัมภายใต้สมมติฐาน
ปัจจุบัน โครงสร้างพื้นฐานที่อิงแฮชเป็นส่วนที่แข็งแกร่งที่สุดของระบบหลังยุค
ควอนตัม

## ภัยคุกคามแบบย้อนหลังเทียบกับแบบเรียลไทม์

ความแตกต่างนี้สำคัญมากสำหรับการจัดลำดับความสำคัญว่าต้องแก้ไขอะไรและเมื่อใด

**ภัยคุกคามแบบย้อนหลัง** ทำลายข้อมูลที่จัดเก็บไว้แล้ว ผู้โจมตีบันทึกข้อมูล
วันนี้และถอดรหัสเมื่อคอมพิวเตอร์ควอนตัมพร้อมใช้งาน ภัยคุกคามเหล่านี้
**ไม่สามารถบรรเทาได้หลังจากเกิดขึ้น** — เมื่อข้อมูลอยู่บน on-chain แล้ว ไม่
สามารถเข้ารหัสใหม่หรือเรียกคืนได้

**ภัยคุกคามแบบเรียลไทม์** ส่งผลกระทบเฉพาะธุรกรรมที่สร้างขึ้นในอนาคต
ผู้โจมตีที่มีคอมพิวเตอร์ควอนตัมสามารถปลอมแปลงลายเซ็นหรือหลักฐาน แต่เฉพาะ
สำหรับธุรกรรมใหม่ ธุรกรรมเก่าได้รับการตรวจสอบและยืนยันโดยเครือข่ายแล้ว

| ภัยคุกคาม | ประเภท | สิ่งที่เปิดเผย | ความเร่งด่วน |
|----------|--------|---------------|-------------|
| **การถอดรหัส note** (enc_ciphertext) | **ย้อนหลัง** | เนื้อหา note: ผู้รับ, จำนวน, memo, rseed | **สูง** — จัดเก็บตลอดไป |
| **การเปิด value commitment** (cv_net) | **ย้อนหลัง** | จำนวนธุรกรรม (แต่ไม่ใช่ผู้ส่ง/ผู้รับ) | **ปานกลาง** — จำนวนเท่านั้น |
| **ข้อมูลกู้คืนผู้ส่ง** (out_ciphertext) | **ย้อนหลัง** | กุญแจกู้คืนของผู้ส่งสำหรับ notes ที่ส่ง | **สูง** — จัดเก็บตลอดไป |
| การปลอมแปลงการอนุญาตการใช้จ่าย | เรียลไทม์ | สามารถปลอมแปลงลายเซ็นการใช้จ่ายใหม่ | ต่ำ — อัปเกรดก่อน QC มาถึง |
| การปลอมแปลงหลักฐาน Halo 2 | เรียลไทม์ | สามารถปลอมแปลงหลักฐานใหม่ (ของปลอม) | ต่ำ — อัปเกรดก่อน QC มาถึง |
| การชนของ Sinsemilla | เรียลไทม์ | สามารถปลอมแปลงเส้นทาง Merkle ใหม่ | ต่ำ — รวมอยู่ในการปลอมแปลงหลักฐาน |
| การปลอมแปลงลายเซ็น binding | เรียลไทม์ | สามารถปลอมแปลงหลักฐานยอดคงเหลือใหม่ | ต่ำ — อัปเกรดก่อน QC มาถึง |

### สิ่งที่เปิดเผยจริงๆ คืออะไร?

**หากการเข้ารหัส note ถูกทำลาย** (ภัยคุกคาม HNDL หลัก):

ผู้โจมตีควอนตัมกู้คืน `esk` จาก `epk` ที่จัดเก็บผ่านอัลกอริทึมของ Shor
คำนวณ shared secret ของ ECDH สร้างกุญแจสมมาตร และถอดรหัส `enc_ciphertext`
ซึ่งเปิดเผย plaintext ของ note ทั้งหมด:

| ฟิลด์ | ขนาด | สิ่งที่เปิดเผย |
|-------|------|---------------|
| version | 1 byte | เวอร์ชันโปรโตคอล (ไม่ละเอียดอ่อน) |
| diversifier | 11 bytes | ส่วนประกอบที่อยู่ของผู้รับ |
| value | 8 bytes | จำนวนธุรกรรมที่แน่นอน |
| rseed | 32 bytes | ทำให้สามารถเชื่อมโยง nullifier (เปิดเผยตัวตนกราฟธุรกรรม) |
| memo | 36 bytes (DashMemo) | ข้อมูลแอปพลิเคชัน อาจระบุตัวตนได้ |

ด้วย `rseed` และ `rho` (จัดเก็บพร้อมกับ ciphertext) ผู้โจมตีสามารถคำนวณ
`esk = PRF(rseed, rho)` และตรวจสอบ binding ของกุญแจชั่วคราว เมื่อรวมกับ
diversifier สิ่งนี้เชื่อมโยงอินพุตกับเอาต์พุตทั่วทั้งประวัติธุรกรรม —
**การเปิดเผยตัวตนอย่างสมบูรณ์ของ shielded pool**

**หากเฉพาะ value commitments ถูกทำลาย** (ภัยคุกคาม HNDL รอง):

ผู้โจมตีกู้คืน `v` จาก `cv_net = [v]*V + [rcv]*R` โดยการแก้ ECDLP สิ่งนี้
เปิดเผย **จำนวนธุรกรรมแต่ไม่ใช่ตัวตนของผู้ส่งหรือผู้รับ** ผู้โจมตีเห็น
"ใครบางคนส่ง 5.0 Dash ให้ใครบางคน" แต่ไม่สามารถเชื่อมโยงจำนวนกับที่อยู่หรือ
ตัวตนใดโดยไม่ทำลายการเข้ารหัส note ด้วย

ด้วยตัวเอง จำนวนที่ไม่มีการเชื่อมโยงมีประโยชน์จำกัด แต่เมื่อรวมกับข้อมูล
ภายนอก (เวลา, ใบแจ้งหนี้ที่ทราบ, จำนวนที่ตรงกับคำขอสาธารณะ) การโจมตีแบบ
สหสัมพันธ์จะเป็นไปได้

## การโจมตี "Harvest Now, Decrypt Later"

นี่คือภัยคุกคามควอนตัมที่เร่งด่วนและใช้งานได้จริงที่สุด

**โมเดลการโจมตี:** ผู้โจมตีระดับรัฐ (หรือฝ่ายใดก็ตามที่มีพื้นที่จัดเก็บ
เพียงพอ) บันทึกข้อมูลธุรกรรมแบบปกปิดบน on-chain ทั้งหมดวันนี้ ข้อมูลนี้เปิด
เผยต่อสาธารณะบนบล็อกเชนและไม่สามารถเปลี่ยนแปลงได้ ผู้โจมตีรอคอมพิวเตอร์
ควอนตัมที่เกี่ยวข้องกับการเข้ารหัส (CRQC) จากนั้น:

```text
Step 1: Read stored record from CommitmentTree BulkAppendTree:
        cmx (32) || rho (32) || epk (32) || enc_ciphertext (104) || out_ciphertext (80)

Step 2: Solve ECDLP on Pallas via Shor's algorithm:
        epk = [esk] * g_d  →  recover esk

Step 3: Compute shared secret:
        shared_secret = [esk] * pk_d

Step 4: Derive symmetric key (BLAKE2b is quantum-safe, but input is compromised):
        K_enc = BLAKE2b-256("Zcash_OrchardKDF", shared_secret || epk)

Step 5: Decrypt enc_ciphertext using ChaCha20-Poly1305:
        → version || diversifier || value || rseed || memo

Step 6: With rseed + rho, link nullifiers to note commitments:
        esk = PRF(rseed, rho)
        → full transaction graph reconstruction
```

**ข้อมูลเชิงลึกสำคัญ:** การเข้ารหัสสมมาตร (ChaCha20-Poly1305) ปลอดภัยจาก
ควอนตัมอย่างสมบูรณ์ ช่องโหว่อยู่ที่ **เส้นทางการสร้างกุญแจ** ทั้งหมด — กุญแจ
สมมาตรสร้างจาก shared secret ของ ECDH และ ECDH ถูกทำลายโดยอัลกอริทึมของ Shor
ผู้โจมตีไม่ได้ทำลายการเข้ารหัส; พวกเขากู้คืนกุญแจ

**การย้อนหลัง:** การโจมตีนี้เป็น **แบบย้อนหลังอย่างสมบูรณ์** note ที่เข้ารหัส
ทุกรายการที่เคยจัดเก็บบน on-chain สามารถถอดรหัสได้เมื่อ CRQC มีอยู่ ข้อมูลไม่
สามารถเข้ารหัสใหม่หรือป้องกันได้หลังจากเกิดขึ้น นี่คือเหตุผลที่ต้องจัดการก่อน
ที่ข้อมูลจะถูกจัดเก็บ ไม่ใช่หลังจากนั้น

## การบรรเทา: KEM แบบไฮบริด (ML-KEM + ECDH)

การป้องกัน HNDL คือการสร้างกุญแจเข้ารหัสสมมาตรจาก **กลไกการตกลงกุญแจ
อิสระสองตัว** เพื่อให้การทำลายเพียงตัวเดียวไม่เพียงพอ สิ่งนี้เรียกว่า KEM
แบบไฮบริด

### ML-KEM-768 (CRYSTALS-Kyber)

ML-KEM เป็นกลไกห่อหุ้มกุญแจหลังยุคควอนตัมที่ได้มาตรฐาน NIST (FIPS 203,
สิงหาคม 2024) อิงจากปัญหา Module Learning With Errors (MLWE)

| พารามิเตอร์ | ML-KEM-512 | ML-KEM-768 | ML-KEM-1024 |
|------------|-----------|-----------|------------|
| Public key (ek) | 800 bytes | **1,184 bytes** | 1,568 bytes |
| Ciphertext (ct) | 768 bytes | **1,088 bytes** | 1,568 bytes |
| Shared secret | 32 bytes | 32 bytes | 32 bytes |
| หมวดหมู่ NIST | 1 (128-bit) | **3 (192-bit)** | 5 (256-bit) |

**ML-KEM-768** เป็นตัวเลือกที่แนะนำ — เป็นชุดพารามิเตอร์ที่ใช้โดย X-Wing,
PQXDH ของ Signal และการแลกเปลี่ยนกุญแจแบบไฮบริด TLS ของ Chrome/Firefox
หมวดหมู่ 3 ให้ระยะห่างที่สบายต่อความก้าวหน้าของการวิเคราะห์รหัส lattice ใน
อนาคต

### วิธีการทำงานของรูปแบบไฮบริด

**ขั้นตอนปัจจุบัน (เสี่ยง):**

```text
Sender:
  esk = PRF(rseed, rho)                    // deterministic from note
  epk = [esk] * g_d                         // Pallas curve point
  shared_secret = [esk] * pk_d              // ECDH (broken by Shor's)
  K_enc = BLAKE2b("Zcash_OrchardKDF", shared_secret || epk)
  enc_ciphertext = ChaCha20(K_enc, note_plaintext)
```

**ขั้นตอนแบบไฮบริด (ทนต่อควอนตัม):**

```text
Sender:
  esk = PRF(rseed, rho)                    // unchanged
  epk = [esk] * g_d                         // unchanged
  ss_ecdh = [esk] * pk_d                    // same ECDH

  (ct_pq, ss_pq) = ML-KEM-768.Encaps(ek_pq)  // NEW: lattice-based KEM
                                                // ek_pq from recipient's address

  K_enc = BLAKE2b(                          // MODIFIED: combines both secrets
      "DashPlatform_HybridKDF",
      ss_ecdh || ss_pq || ct_pq || epk
  )

  enc_ciphertext = ChaCha20(K_enc, note_plaintext)  // unchanged
```

**การถอดรหัสของผู้รับ:**

```text
Recipient:
  ss_ecdh = [ivk] * epk                    // same ECDH (using incoming viewing key)
  ss_pq = ML-KEM-768.Decaps(dk_pq, ct_pq)  // NEW: KEM decapsulation
  K_enc = BLAKE2b("DashPlatform_HybridKDF", ss_ecdh || ss_pq || ct_pq || epk)
  note_plaintext = ChaCha20.Decrypt(K_enc, enc_ciphertext)
```

### การรับประกันความปลอดภัย

KEM แบบรวมมีความปลอดภัย IND-CCA2 หาก KEM ส่วนประกอบ **ตัวใดตัวหนึ่ง**
ปลอดภัย สิ่งนี้ได้รับการพิสูจน์อย่างเป็นทางการโดย
[Giacon, Heuer, และ Poettering (2018)](https://eprint.iacr.org/2018/024)
สำหรับตัวรวม KEM ที่ใช้ PRF (BLAKE2b มีคุณสมบัติ) และโดยอิสระจาก
[หลักฐานความปลอดภัยของ X-Wing](https://eprint.iacr.org/2024/039)

| สถานการณ์ | ECDH | ML-KEM | กุญแจรวม | สถานะ |
|----------|------|--------|---------|-------|
| โลกแบบคลาสสิก | ปลอดภัย | ปลอดภัย | **ปลอดภัย** | ทั้งคู่สมบูรณ์ |
| ควอนตัมทำลาย ECC | **ถูกทำลาย** | ปลอดภัย | **ปลอดภัย** | ML-KEM ป้องกัน |
| ความก้าวหน้า lattice ทำลาย ML-KEM | ปลอดภัย | **ถูกทำลาย** | **ปลอดภัย** | ECDH ป้องกัน (เหมือนปัจจุบัน) |
| ทั้งคู่ถูกทำลาย | ถูกทำลาย | ถูกทำลาย | **ถูกทำลาย** | ต้องการสองความก้าวหน้าพร้อมกัน |

### ผลกระทบด้านขนาด

KEM แบบไฮบริดเพิ่ม ciphertext ของ ML-KEM-768 (1,088 bytes) ให้กับแต่ละ note
ที่จัดเก็บ และขยาย outgoing ciphertext เพื่อรวม shared secret ของ ML-KEM
สำหรับการกู้คืนผู้ส่ง:

**บันทึกที่จัดเก็บต่อ note:**

```text
┌──────────────────────────────────────────────────────────────────┐
│  Current (280 bytes)         Hybrid (1,400 bytes)               │
│                                                                  │
│  cmx:             32         cmx:              32               │
│  rho:             32         rho:              32               │
│  epk:             32         epk:              32               │
│  enc_ciphertext: 104         ct_pq:         1,088  ← NEW       │
│  out_ciphertext:  80         enc_ciphertext:  104               │
│                              out_ciphertext:  112  ← +32        │
│  ─────────────────           ──────────────────────             │
│  Total:          280         Total:          1,400  (5.0x)      │
└──────────────────────────────────────────────────────────────────┘
```

**พื้นที่จัดเก็บในระดับใหญ่:**

| Notes | ปัจจุบัน (280 B) | ไฮบริด (1,400 B) | Delta |
|-------|-----------------|------------------|-------|
| 100,000 | 26.7 MB | 133 MB | +106 MB |
| 1,000,000 | 267 MB | 1.33 GB | +1.07 GB |
| 10,000,000 | 2.67 GB | 13.3 GB | +10.7 GB |

**ขนาดที่อยู่:**

```text
Current:  diversifier (11) + pk_d (32) = 43 bytes
Hybrid:   diversifier (11) + pk_d (32) + ek_pq (1,184) = 1,227 bytes
```

public key ของ ML-KEM 1,184 bytes ต้องรวมอยู่ในที่อยู่เพื่อให้ผู้ส่งสามารถทำ
การห่อหุ้มได้ ที่ ~1,960 อักขระ Bech32m มันมีขนาดใหญ่แต่ยังพอดีใน QR code
(สูงสุด ~2,953 อักขระตัวอักษรและตัวเลข)

### การจัดการกุญแจ

คู่กุญแจ ML-KEM สร้างแบบกำหนดได้จาก spending key:

```text
SpendingKey (sk) [32 bytes]
  |
  +-> ... (all existing Orchard key derivation unchanged)
  |
  +-> ml_kem_d = PRF^expand(sk, [0x09])[0..32]
  +-> ml_kem_z = PRF^expand(sk, [0x0A])[0..32]
        |
        +-> (ek_pq, dk_pq) = ML-KEM-768.KeyGen(d=ml_kem_d, z=ml_kem_z)
              ek_pq: 1,184 bytes (public, included in address)
              dk_pq: 2,400 bytes (private, part of viewing key)
```

**ไม่จำเป็นต้องเปลี่ยนแปลงการสำรองข้อมูล** วลี seed 24 คำที่มีอยู่ครอบคลุม
กุญแจ ML-KEM เพราะสร้างจาก spending key แบบกำหนดได้ การกู้คืนกระเป๋าเงิน
ทำงานเหมือนเดิม

**ที่อยู่แบบหลากหลาย** ทั้งหมดใช้ `ek_pq` เดียวกันเพราะ ML-KEM ไม่มีกลไก
การกระจายแบบธรรมชาติเหมือนการคูณสเกลาร์ของ Pallas ซึ่งหมายความว่าผู้สังเกต
ที่มีที่อยู่สองแห่งของผู้ใช้สามารถเชื่อมโยงที่อยู่เหล่านั้นได้โดยเปรียบเทียบ
`ek_pq`

### ประสิทธิภาพ Trial Decryption

| ขั้นตอน | ปัจจุบัน | ไฮบริด | Delta |
|---------|---------|--------|-------|
| Pallas ECDH | ~100 us | ~100 us | — |
| ML-KEM-768 Decaps | — | ~40 us | +40 us |
| BLAKE2b KDF | ~0.5 us | ~1 us | — |
| ChaCha20 (52 bytes) | ~0.1 us | ~0.1 us | — |
| **รวมต่อ note** | **~101 us** | **~141 us** | **+40% overhead** |

การสแกน 100,000 notes: ~10.1 วินาที → ~14.1 วินาที ค่าใช้จ่ายเพิ่มเติมมี
ความสำคัญแต่ไม่มากเกินไป การถอดห่อ ML-KEM ทำงานในเวลาคงที่โดยไม่มีข้อได้
เปรียบจากการประมวลผลเป็นชุด (ไม่เหมือนการดำเนินการเส้นโค้งวงรี) จึงขยาย
แบบเชิงเส้น

### ผลกระทบต่อวงจร ZK

**ไม่มี** KEM แบบไฮบริดอยู่ในชั้นการขนส่ง/เข้ารหัสทั้งหมด วงจร Halo 2
พิสูจน์การมีอยู่ของ note ความถูกต้องของ nullifier และความสมดุลของค่า — ไม่ได้
พิสูจน์อะไรเกี่ยวกับการเข้ารหัส ไม่มีการเปลี่ยนแปลง proving keys, verifying
keys หรือข้อจำกัดของวงจร

### การเปรียบเทียบกับอุตสาหกรรม

| ระบบ | แนวทาง | สถานะ |
|------|--------|-------|
| **Signal** (PQXDH) | X25519 + ML-KEM-768, บังคับสำหรับผู้ใช้ทุกคน | **ใช้งานแล้ว** (2023) |
| **Chrome/Firefox TLS** | X25519 + ML-KEM-768 การแลกเปลี่ยนกุญแจแบบไฮบริด | **ใช้งานแล้ว** (2024) |
| **X-Wing** (ร่าง IETF) | X25519 + ML-KEM-768, ตัวรวมที่สร้างขึ้นเฉพาะ | ร่างมาตรฐาน |
| **Zcash** | ร่าง ZIP การกู้คืนควอนตัม (กู้คืนเงิน ไม่ใช่เข้ารหัส) | อยู่ในขั้นอภิปราย |
| **Dash Platform** | Pallas ECDH + ML-KEM-768 (เสนอ) | ขั้นออกแบบ |

## เมื่อใดควรนำไปใช้

### คำถามเรื่องกรอบเวลา

- **สถานะปัจจุบัน (2026):** ไม่มีคอมพิวเตอร์ควอนตัมใดที่สามารถทำลาย ECC
  255 บิตได้ การแยกตัวประกอบด้วยควอนตัมที่ใหญ่ที่สุดที่แสดงให้เห็น: ~50 บิต
  ช่องว่าง: หลายลำดับขนาด
- **ระยะใกล้ (2030-2035):** แผนงานฮาร์ดแวร์จาก IBM, Google, Quantinuum
  ตั้งเป้าหลายล้านคิวบิต การนำ ML-KEM ไปใช้และชุดพารามิเตอร์จะเติบโตเต็มที่
- **ระยะกลาง (2035-2050):** การประมาณส่วนใหญ่วาง CRQC ไว้ในช่วงนี้ ข้อมูล
  HNDL ที่รวบรวมวันนี้มีความเสี่ยง
- **ระยะยาว (2050+):** ฉันทามติในหมู่นักเข้ารหัส: คอมพิวเตอร์ควอนตัมขนาดใหญ่
  เป็นเรื่องของ "เมื่อใด" ไม่ใช่ "หรือไม่"

### กลยุทธ์ที่แนะนำ

**1. ออกแบบให้อัปเกรดได้ตั้งแต่ตอนนี้** ตรวจสอบให้แน่ใจว่ารูปแบบบันทึกที่
จัดเก็บ struct `TransmittedNoteCiphertext` และเค้าโครงรายการ BulkAppendTree
มีการกำหนดเวอร์ชันและขยายได้ สิ่งนี้มีต้นทุนต่ำและรักษาตัวเลือกในการเพิ่ม
KEM แบบไฮบริดในภายหลัง

**2. นำ KEM แบบไฮบริดไปใช้เมื่อพร้อม ทำให้เป็นข้อบังคับ** อย่าเสนอสอง pool
(แบบคลาสสิกและไฮบริด) การแยกชุดนิรนามทำลายจุดประสงค์ของธุรกรรมแบบปกปิด —
ผู้ใช้ที่ซ่อนตัวในกลุ่มที่เล็กกว่ามีความเป็นส่วนตัวน้อยลง ไม่ใช่มากขึ้น
เมื่อนำไปใช้ ทุก note ใช้รูปแบบไฮบริด

**3. ตั้งเป้าช่วง 2028-2030** ซึ่งอยู่ก่อนภัยคุกคามควอนตัมที่เป็นจริงใดๆ
อย่างมากแต่หลังจากการนำ ML-KEM ไปใช้และขนาดพารามิเตอร์ได้เสถียรแล้ว ยัง
อนุญาตให้เรียนรู้จากประสบการณ์การนำไปใช้ของ Zcash และ Signal

**4. ตรวจสอบเหตุการณ์ที่เป็นตัวกระตุ้น:**
- NIST หรือ NSA กำหนดเส้นตายการย้ายหลังยุคควอนตัม
- ความก้าวหน้าสำคัญในฮาร์ดแวร์ควอนตัม (>100,000 คิวบิตทางกายภาพพร้อมการ
  แก้ไขข้อผิดพลาด)
- ความก้าวหน้าในการวิเคราะห์รหัสต่อปัญหา lattice (จะส่งผลต่อตัวเลือก ML-KEM)

### สิ่งที่ไม่จำเป็นต้องดำเนินการเร่งด่วน

| ส่วนประกอบ | เหตุผลที่รอได้ |
|-----------|---------------|
| ลายเซ็นการอนุญาตการใช้จ่าย | การปลอมแปลงเป็นแบบเรียลไทม์ ไม่ย้อนหลัง อัปเกรดเป็น ML-DSA/SLH-DSA ก่อน CRQC มาถึง |
| ระบบพิสูจน์ Halo 2 | การปลอมแปลงหลักฐานเป็นแบบเรียลไทม์ ย้ายไประบบที่อิง STARK เมื่อจำเป็น |
| ความต้านทานการชนของ Sinsemilla | มีประโยชน์เฉพาะสำหรับการโจมตีใหม่ ไม่ย้อนหลัง รวมอยู่ในการย้ายระบบพิสูจน์ |
| โครงสร้างพื้นฐาน GroveDB Merk/MMR/Blake3 | **ถือว่าปลอดภัยจากควอนตัมภายใต้สมมติฐานและมาตรฐานปัจจุบัน** ไม่จำเป็นต้องดำเนินการในขณะนี้ |

## เอกสารอ้างอิงทางเลือกหลังยุคควอนตัม

### สำหรับการเข้ารหัส (แทนที่ ECDH)

| รูปแบบ | ประเภท | Public key | Ciphertext | หมวดหมู่ NIST | หมายเหตุ |
|--------|--------|-----------|-----------|---------------|---------|
| ML-KEM-768 | Lattice (MLWE) | 1,184 B | 1,088 B | 3 (192-bit) | FIPS 203, มาตรฐานอุตสาหกรรม |
| ML-KEM-512 | Lattice (MLWE) | 800 B | 768 B | 1 (128-bit) | เล็กกว่า ระยะห่างน้อยกว่า |
| ML-KEM-1024 | Lattice (MLWE) | 1,568 B | 1,568 B | 5 (256-bit) | มากเกินไปสำหรับไฮบริด |

### สำหรับลายเซ็น (แทนที่ RedPallas/Schnorr)

| รูปแบบ | ประเภท | Public key | Signature | หมวดหมู่ NIST | หมายเหตุ |
|--------|--------|-----------|----------|---------------|---------|
| ML-DSA-65 (Dilithium) | Lattice | 1,952 B | 3,293 B | 3 | FIPS 204, เร็ว |
| SLH-DSA (SPHINCS+) | อิงแฮช | 32-64 B | 7,856-49,856 B | 1-5 | FIPS 205, อนุรักษ์นิยม |
| XMSS/LMS | อิงแฮช (stateful) | 60 B | 2,500 B | แตกต่างกัน | Stateful — ใช้ซ้ำ = ถูกทำลาย |

### สำหรับหลักฐาน ZK (แทนที่ Halo 2)

| ระบบ | สมมติฐาน | ขนาดหลักฐาน | หลังยุคควอนตัม | หมายเหตุ |
|------|---------|------------|---------------|---------|
| STARKs | Hash functions (collision resistance) | ~100-400 KB | **ใช่** | ใช้โดย StarkNet |
| Plonky3 | FRI (hash-based polynomial commitment) | ~50-200 KB | **ใช่** | กำลังพัฒนา |
| Halo 2 (ปัจจุบัน) | ECDLP on Pasta curves | ~5 KB | **ไม่** | ระบบ Orchard ปัจจุบัน |
| Lattice SNARKs | MLWE | วิจัย | **ใช่** | ยังไม่พร้อมสำหรับการผลิต |

### ระบบนิเวศ Crate ของ Rust

| Crate | แหล่งที่มา | FIPS 203 | ตรวจสอบแล้ว | หมายเหตุ |
|-------|-----------|----------|------------|---------|
| `libcrux-ml-kem` | Cryspen | ใช่ | ตรวจสอบอย่างเป็นทางการ (hax/F*) | การรับประกันสูงสุด |
| `ml-kem` | RustCrypto | ใช่ | Constant-time, ยังไม่ได้ตรวจสอบ | ความเข้ากันได้กับระบบนิเวศ |
| `fips203` | integritychain | ใช่ | Constant-time | Pure Rust, no_std |

## สรุป

```text
┌─────────────────────────────────────────────────────────────────────┐
│  สรุปภัยคุกคามควอนตัมสำหรับ GROVEDB + ORCHARD                       │
│                                                                     │
│  ปลอดภัยภายใต้สมมติฐานปัจจุบัน (ใช้แฮช):                             │
│    ✓ Blake3 Merk trees, MMR, BulkAppendTree                        │
│    ✓ BLAKE2b KDF, PRF^expand                                       │
│    ✓ การเข้ารหัสแบบสมมาตร ChaCha20-Poly1305                        │
│    ✓ ห่วงโซ่การพิสูจน์ตัวตนทั้งหมดของ GroveDB                       │
│                                                                     │
│  แก้ไขก่อนจัดเก็บข้อมูล (HNDL ย้อนหลัง):                            │
│    ✗ การเข้ารหัสโน้ต (ข้อตกลงกุญแจ ECDH) → KEM แบบไฮบริด          │
│    ✗ การผูกมัดค่า (Pedersen) → จำนวนเงินถูกเปิดเผย                  │
│                                                                     │
│  แก้ไขก่อนคอมพิวเตอร์ควอนตัมมาถึง (เรียลไทม์เท่านั้น):              │
│    ~ การอนุมัติการใช้จ่าย → ML-DSA / SLH-DSA                       │
│    ~ การพิสูจน์ ZK → STARKs / Plonky3                              │
│    ~ Sinsemilla → ต้นไม้ Merkle แบบแฮช                              │
│                                                                     │
│  กำหนดเวลาที่แนะนำ:                                                  │
│    2026-2028: ออกแบบให้อัปเกรดได้ กำหนดเวอร์ชันรูปแบบจัดเก็บ       │
│    2028-2030: นำ KEM ไฮบริดบังคับไปใช้สำหรับเข้ารหัสโน้ต           │
│    2035+: ย้ายลายเซ็นและระบบพิสูจน์หากจำเป็น                        │
└─────────────────────────────────────────────────────────────────────┘
```

---
